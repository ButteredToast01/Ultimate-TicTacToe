<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Ultimate Tic Tac Toe</title>
<style>
  /* Make borders count inside sizes, everywhere */
  *, *::before, *::after { box-sizing: border-box; }

  body {
    font-family: Arial, sans-serif;
    text-align: center;
    background: #f0f0f0;
  }
  h1 { margin: 10px; }
  #turn { font-size: 20px; margin: 10px; }

  /* Big board: 3x3 layout of small boards */
  #board {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 10px;
    width: 660px;
    margin: 20px auto;
  }

  /* Each small 3x3 board (fixed size) */
  .small-board {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr); /* Lock row heights */
    border: 3px solid black;
    gap: 2px;
    width: 200px;
    height: 200px;
    position: relative;
  }

  /* Highlights the active board small board */
  .active-board {
    outline: 4px solid orange;
  }

  /* Individual cell */
  .cell {
    border: 1px solid #888;
    background: white;
    font-size: 28px; /* Comfy size for 66Ã—66 cells */
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    user-select: none;

    /* Ensures content never changes cell size */
    width: 100%;
    height: 100%;
    min-width: 0;
    min-height: 0;
    overflow: hidden;
    line-height: 1;
    white-space: nowrap;
  }

  /* Small board backgrounds when won */
  .background-overlay.X-won { background-color: rgba(255, 0, 0, 0.2); } /* Red tint */
  .background-overlay.O-won { background-color: rgba(0, 0, 255, 0.2); } /* Blue tint */
  .background-overlay.draw { background-color: rgba(128, 128, 128, 0.2); } /* Grey tint */
  
  /* Overlay of symbol */
  .won-overlay {
    position: absolute;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    font-size: 60px;
    font-weight: bold;
    pointer-events: none;
    background: none;
  }

  /* Colour of overlay symbols */
  .won-overlay.X { color: #FF4136; } /* Red for X */
  .won-overlay.O { color: #0074D9; } /* Blue for O */
  .won-overlay.draw { color: gray; } /* Gray for draw */

  .cell.X { color: #FF4136; } /* Red X */
  .cell.O { color: #0074D9; } /* Blue O */

  .small-board .background-overlay {
    position: absolute;
    top: 0; left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* clicks pass through to cells */
    z-index: 0; /* behind the cells */
    border-radius: 0; /* optional */
  }
  
</style>
</head>
<body>
<h1>Ultimate Tic Tac Toe</h1>
<div id="turn">Turn: X</div>
<div id="board"></div>
<div id="message"></div>

<script>
const boardElement = document.getElementById('board');
const turnElement = document.getElementById('turn');
const messageElement = document.getElementById('message');

let currentPlayer = 'X';
let boards = []; // 9 small boards (each is an array of 9 cells)
let boardStatus = Array(9).fill(null); // null, 'X', 'O', or 'draw'
let nextBoard = null; // 0-8 or null (free move)

// Build the 9 small boards
for (let i = 0; i < 9; i++) {
  const small = document.createElement('div');
  small.classList.add('small-board');
  small.dataset.index = i;
  boards[i] = Array(9).fill(null);

  for (let j = 0; j < 9; j++) {
    const cell = document.createElement('div');
    cell.classList.add('cell');
    cell.dataset.index = j;
    cell.dataset.board = i;
    cell.addEventListener('click', cellClick);
    small.appendChild(cell);
  }
  boardElement.appendChild(small);
}

// Visually highlight where the next move can be played
function updateActiveBoard() {
  const smallBoards = document.querySelectorAll('.small-board');
  smallBoards.forEach((board, i) => {
    board.classList.remove('active-board');
    if (boardStatus[i]) return; // skip won/drawn boards
    if (nextBoard === null) {
      board.classList.add('active-board'); // free move: highlight all playable
    } else if (nextBoard === i) {
      board.classList.add('active-board'); // forced board
    }
  });
}

function cellClick(e) {
  const boardIndex = parseInt(e.target.dataset.board);
  const cellIndex = parseInt(e.target.dataset.index);

  // Invalid move checks
  if (boardStatus[boardIndex] || boards[boardIndex][cellIndex] ||
     (nextBoard !== null && boardIndex !== nextBoard)) {
    return;
  }

  // Place the mark
  boards[boardIndex][cellIndex] = currentPlayer;
  e.target.textContent = currentPlayer;
  e.target.classList.add(currentPlayer); /* adds X or O class to the cell */

  // Check small board result
  const winner = checkWinner(boards[boardIndex]);
  if (winner) {
    boardStatus[boardIndex] = winner;

    // Background overlay
    const bg = document.createElement('div');
    bg.classList.add('background-overlay', `${winner}-won`);
    e.target.parentElement.appendChild(bg);

    //Show overlay symbol
    const overlay = document.createElement('div');
    overlay.classList.add('won-overlay', winner);
    overlay.textContent = winner;
    e.target.parentElement.appendChild(overlay);
    
  } else if (boards[boardIndex].every(c => c)) {
    boardStatus[boardIndex] = 'draw';
    e.target.parentElement.classList.add('draw');
    const overlay = document.createElement('div');
    overlay.classList.add('won-overlay', 'draw');
    overlay.textContent = ' ';
    e.target.parentElement.appendChild(overlay);
  }

  // Check big board result
  const bigWinner = checkWinner(boardStatus.map(s => s==='draw' ? null : s));
  if (bigWinner) {
    messageElement.textContent = `ðŸŽ‰ Player ${bigWinner} wins the game! ðŸŽ‰`;
    turnElement.textContent = '';
    document.querySelectorAll('.small-board').forEach(b => b.classList.remove('active-board'));
    return;
  } else if (boardStatus.every(s => s)) {
    messageElement.textContent = 'Draw!';
    turnElement.textContent = '';
    document.querySelectorAll('.small-board').forEach(b => b.classList.remove('active-board'));
    return;
  }

  // Determine the next required board
  nextBoard = boardStatus[cellIndex] ? null : cellIndex;

  // Switch player and refresh highlight
  currentPlayer = currentPlayer === 'X' ? 'O' : 'X';
  turnElement.textContent = `Turn: ${currentPlayer}`;
  updateActiveBoard();
}

// Check a 3x3 for a winner
function checkWinner(cells) {
  const lines = [
    [0,1,2],[3,4,5],[6,7,8], // rows
    [0,3,6],[1,4,7],[2,5,8], // columns
    [0,4,8],[2,4,6]          // diagonals
  ];
  for (const [a,b,c] of lines) {
    if (cells[a] && cells[a] === cells[b] && cells[a] === cells[c]) return cells[a];
  }
  return null;
}

// Initial highlight (free move at start)
updateActiveBoard();
</script>
</body>
</html>
